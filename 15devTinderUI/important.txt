using custom validators in mongoose schema:
    //validate key takes two values, first validator function, then message on error
    validate: {
        validator : (value)=>{
            return true/false;
        },
        message: "this shows up when false"
    }

    using enum: when options are few predefined values:
    enum:{
        values:["val1", "val2"],
        message:"error msg"
    }

      private key is "null" in string



    res.cookie(arg1, arg2) ->its a function 
        arg1 == name of token , always in STRING!!!!!!!!!
        arg2 == data of token



    IN MONGOOSE, USE ONE STYLE , BOTH CANT BE USED AT ONCE:
        A. AYNC/AWAIT
        B. NEXT




====================================================
    #####   NEW KEYWORD IMPORTANCE   ######
Mongoose creating and updating differnec:
    when we create a new instance of model, we use :
        const req= new User({})......

        this sets internally for req:   this.isNew = true

    when we dont use new keyword for creating/updating:

        const req= User.findById({_id})

        this sets internally for req:   this.isNew = false


    use it inside pre function to check if a document is being created or modified!!!


=========================================================================== 
    UPDATING A DOCUMENT AND USING $set:::

    ConnectionRequestModel.updateOne(
    { _id: id },
    { status: "accepted" }
        );===>    DOING THIS WILL CLEAR THE fromUserId and toUserId  and juts keep status=accepted


    SO instead:
    ConnectionRequestModel.updateOne(
        {_id: id },
        { $set: { status: "accepted" } }
    );

    ONLY UPDATE STATUS AND KEEP THE REST AS ITIS

========================================================================================
COMPOUNT INDEX:

 in model-file.js 
    schemaName.index({attr1:1, attr2:1 , attr3:1})      => stores according to the acsending order




===========================================================================================
NOW META-DATA STUFF: ref-populate::::

    relation bw two tables:
        just : ref:"User" -> inside fromUserId,toUserId creates the reference

    populate :
        user when finding from User Table(the one for which ref was created)

        just:ConnectionRequestModel.find({}).populate("reffed attr", [array of User properties])

    filtering :
        to send just some specific data ->
        from the whole data object, we need just the info about fromUserId, then we do map on it and just take the fromUserId by:
        const data= friendConnections.map((doc)=>doc.fromUserId);

    in friendConnections , we are sending the friends name back, we check if status of connection is accepted , but we dont check whether the req was send by current user to other or received, and just populating the fromUserIdd only.
    In case if we send it , fromUserId will be ours and we will be shown in our own friends Field!!!
    so to fix it we do:
        check which one of from/to is loggedIN, and then pass the other in data

    so while saving/sending data, we can use map to do stuff
